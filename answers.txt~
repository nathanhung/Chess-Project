Question: Chess programs usually come with a book of standard opening move sequences. These
are moves from classical strategies that many chess players have memorized. A standard opening
move sequence is typically a list of accepted opening moves and responses to opponentsâ€™ moves, for
the first dozen or so moves of the game. Although you are not required to support this, discuss
how you would implement a book of standard openings if required.

Answer: For a computer player attempting to use a classical strategy, I would store each strategy as a collection of moves up to the desired length. Let's say the strategy required 50 consecutive moves, I would implement an array of integers and characters and feed these moves into the interpreter turn by turn. This, using my predefined checkValid method would check to see if the piece being played could move to the desired tile, ensure the move would not put my King into a check position, as well as if the tile was available (empty or had opponent's piece). One might argue that this implementation opens the strategy up for exploitation as it makes the Computer unresponsive to the opponent's moves. However, a priority queue could easily be implemented to first check if an enemy piece could be captured, if an ally piece could be saved, if our king was in check and lastly, if none of the above was possible, the strategy would be continued.

Another comprehensive strategy would be to implement an aggresive algorithm that checks up to n moves in the future to see if an enemy piece can be captured. For example, n = 3. Our algorithm will be run on each piece the computer owns; each piece will be analyzed 3 moves into the future to see if with the given location of the piece and the current state of the board (relative positions of enemy pieces) if there is a combination of moves that will allow me to capture an enemy piece. If more than one enemy piece can be captured, values can be assigned such that more powerful pieces are targetted (Queen over Pawns) as well as strategies that require a minimum number of moves as to increase probability of success. If an attack requires 5 moves there is a greater chance that within the next 4 moves, circumstances will change that will disallow you to attack that piece. However, if a strategy only requires 2 moves, there is a reduced entropy and thus a higher chance that the strategy is still relevant.
 

Question: How would you implement a feature that would allow a player to undo his/her last
move? What about an unlimited number of undos?

Answer: If I was to implement an undo feature, I would store each player's moves into a Vector of integers and characters respectively. I would make a special note about piece captures, promotions and castling. Next, I would simply proceed to undo the moves in reverse chronological order switching the move locations. For example the moves (e1 e4, a2 a7, P killed at a7, c5 c3) would be reversed by moving the current piece at c3 back to c3, moving the piece at a7 back to a2 and creating a white Pawn at a7, and finally move the piece at e4 back to e1. This could easily be parsed and fed back into my already defined move interpreter.

Question: Variations on chess abound. For example, four-handed chess is a variant that is played
by four players (search for it!). Outline the changes that would be necessary to make your program
into a four-handed chess game.
